create new query raw(sql: String!): QueryResult!, where QueryResult type has count int, results [MyString] field, i want to be able to query like `raw(sql: "SELECT * FROM users") {
	count
	results(sep: ",", limit: 20)
}`, and the result will be like `1,username,true` for example. limit will only cut the resulting slice and not interfere with raw sql. Then, also create a new mutation raw(sql: String!): int, where int is the affected row count, after executing the raw sql of input.
i want to update how VarKV and VarString parsing work. previosly, pipe is used to separate between key and value, and full colon is used in VarString syntax, in {key:value}. I want to modify both so that full colon is used to separate between key and value, and equal symobol is used in VarString syntax, replacing the full colon, {key=value}. the valid string for VarKV will be `myName:user{userId=1}`, then VarKVGroup used in HttpQueries, HttpHeaders input field's valid input will be like `header1:headerValue1 Token:Barer{token=adsdfsdcd} User-Agent:Mozilla{agentVersion=1.0}`. I want you to write test (big ones at that) parsing the input string for VarKVGroup and VarString. especially for VarKVGroup

remove every updateX,deleteX,patchX mutations in graphql schema. all the update and delete will be done via patch and destroy mutations
if there is no alias set for a reference, it will be referenceTypePrefix + referenceId, for example, end12 (for endpoint of id 12)

# ARchives
i see that you are using string for variables field in runCurl mutation. you should be using KVGroup type from mystructs package as a scalar, it was created for this purpose. every time you need a key-value string, you will use KVGroup. the input string will be in the format "key1:value1 key2:value2 key3:value3", in unmarshalGQL function, make sure you parse the string right. then the resolver function will deal with parsed KVGroup as variables. refactor.
add a new mutation 'patchProgram' to each type in graphql schema that has update mutation(Program,Note,Endpoint,MemorySheet, etc), you may reuse the existing input (NewProgram, for example) or create a new input in schema(if so, place the generated struct in models package). the resolver will only update the non-zero field of the input. (make it reusable, add Patch method on GeneralCrud struct, and reuse it in other services not to repeat yourself)
Is Endpoint model mature enough to contain infromation about an http request,that can be 100% covertable to and from curl command? if not, modify the Endpoint. Add importCurl(curl: String!): NewEndpoint! mutation, not doing a thing to database. i want to see the input NewEndpoint being converted from curl command. I will have to manually copy and paste the returned input to create a new endpoint(at least, for now, later, i might directly create the endpoint from curl)
Add alias field to endpoint, which is optional, to both NewEndpoint and Endpoint, add validation to be unique.
Construct MyRequest struct that have no create, nor input, only a model struct that will record all information like ContentType of response, Size, latency, along with input programId, endpointId, all information that matters in ethical hacking. Then, add runCurl mutation that take endpoint alias, variables KVGroup, that will first inject the variables, execute the Endpoint, generated the Curl command, then run the curl command, store the output/response in MyRequest model. (ProgramId and EndpointId will come from the EndpointId). This will be a big deal so I need you to be very careful, precise with your code.
