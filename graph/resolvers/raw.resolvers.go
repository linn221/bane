package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"

	"github.com/linn221/bane/graph"
	"github.com/linn221/bane/models"
)

// Raw is the resolver for the raw mutation field.
func (r *mutationResolver) Raw(ctx context.Context, sql string) (int, error) {
	// Use gorm to execute Exec; it returns sql.Result
	res := r.DB.WithContext(ctx).Exec(sql)
	if res.Error != nil {
		return 0, res.Error
	}
	// RowsAffected is int64; convert to int
	return int(res.RowsAffected), nil
}

// Raw is the resolver for the raw query field.
func (r *queryResolver) Raw(ctx context.Context, sql string) (*models.QueryResult, error) {
	// Use the underlying *sql.DB from gorm to run raw query safely (no interpolation)
	sqlDB, err := r.DB.DB()
	if err != nil {
		return nil, err
	}

	rows, err := sqlDB.QueryContext(ctx, sql)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	cols, err := rows.Columns()
	if err != nil {
		return nil, err
	}

	var result [][]string
	for rows.Next() {
		// Allocate raw column buffers
		raw := make([][]byte, len(cols))
		dest := make([]interface{}, len(cols))
		for i := range raw {
			dest[i] = &raw[i]
		}
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		// Convert raw bytes to string, handling NULLs
		row := make([]string, len(cols))
		for i, rb := range raw {
			if rb == nil {
				row[i] = "" // represent NULL as empty string
			} else {
				row[i] = string(rb)
			}
		}
		result = append(result, row)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return &models.QueryResult{Rows: result, Count: len(result)}, nil
}

// Results is the resolver for the QueryResult.results field.
func (r *queryResultResolver) Results(ctx context.Context, obj *models.QueryResult, sep *string, limit *int) ([]*string, error) {
	my := obj.ToMyStrings(sep, limit)
	out := make([]*string, 0, len(my))
	for i := range my {
		s := my[i].String()
		out = append(out, &s)
	}
	return out, nil
}

// QueryResult returns graph.QueryResultResolver implementation.
func (r *Resolver) QueryResult() graph.QueryResultResolver { return &queryResultResolver{r} }

type queryResultResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *queryResultResolver) Count(ctx context.Context, obj *models.QueryResult) (int, error) {
    return obj.Count, nil
}
*/
