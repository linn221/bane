package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"

	"github.com/linn221/bane/app"
	"github.com/linn221/bane/graph"
	"github.com/linn221/bane/graph/model"
	"github.com/linn221/bane/loaders"
	"github.com/linn221/bane/models"
	"github.com/linn221/bane/services"
)

// NewProgram is the resolver for the newProgram field.
func (r *mutationResolver) NewProgram(ctx context.Context, input *models.NewProgram) (*models.Program, error) {
	return services.ProgramService.Create(r.DB.WithContext(ctx), input)
}

// UpdateProgram is the resolver for the updateProgram field.
func (r *mutationResolver) UpdateProgram(ctx context.Context, id *int, alias *string, input models.NewProgram) (*models.Program, error) {
	if id != nil {
		return services.ProgramService.UpdateByID(r.DB.WithContext(ctx), &input, *id)
	}
	if alias != nil {
		return services.ProgramService.UpdateByAlias(r.DB.WithContext(ctx), &input, *alias)
	}
	return nil, fmt.Errorf("either id or alias must be provided")
}

// PatchProgram is the resolver for the patchProgram field.
func (r *mutationResolver) PatchProgram(ctx context.Context, id *int, alias *string, input models.PatchProgram) (*models.Program, error) {
	updates := make(map[string]any)

	if input.Name != nil && *input.Name != "" {
		updates["name"] = *input.Name
	}
	if input.Alias != nil && *input.Alias != "" {
		updates["alias"] = *input.Alias
	}
	if input.Description != nil && *input.Description != "" {
		updates["description"] = *input.Description
	}
	if input.Domain != nil && *input.Domain != "" {
		updates["domain"] = *input.Domain
	}
	if input.URL != nil && *input.URL != "" {
		updates["url"] = *input.URL
	}

	if id != nil {
		return services.ProgramService.PatchByID(r.DB.WithContext(ctx), updates, *id)
	}
	if alias != nil {
		return services.ProgramService.PatchByAlias(r.DB.WithContext(ctx), updates, *alias)
	}
	return nil, fmt.Errorf("either id or alias must be provided")
}

// DeleteProgram is the resolver for the deleteProgram field.
func (r *mutationResolver) DeleteProgram(ctx context.Context, id *int, alias *string) (*models.Program, error) {
	if id != nil {
		return services.ProgramService.DeleteByID(r.DB.WithContext(ctx), *id)
	}
	if alias != nil {
		return services.ProgramService.DeleteByAlias(r.DB.WithContext(ctx), *alias)
	}
	return nil, fmt.Errorf("either id or alias must be provided")
}

// Match is the resolver for the match field.
func (r *programResolver) Match(ctx context.Context, obj *models.Program, regex string) (*model.SearchResult, error) {
	return services.MatchRegex(obj, regex)
}

// Rid is the resolver for the rid field.
func (r *programResolver) Rid(ctx context.Context, obj *models.Program) (int, error) {
	return loaders.GetRId(ctx, app.Reference{ReferenceId: obj.Id, ReferenceType: "programs"})
}

// Notes is the resolver for the notes field.
func (r *programResolver) Notes(ctx context.Context, obj *models.Program) ([]*models.Note, error) {
	// Use dataloader for efficient Notes loading
	return loaders.GetNotesForProgram(ctx, obj.Id)
}

// Programs is the resolver for the programs field.
func (r *queryResolver) Programs(ctx context.Context, search *string) ([]*models.Program, error) {
	return services.ProgramService.ListPrograms(r.DB.WithContext(ctx))
}

// Program is the resolver for the program field.
func (r *queryResolver) Program(ctx context.Context, id *int, alias *string) (*models.Program, error) {
	if id != nil {
		return services.ProgramService.GetByID(r.DB.WithContext(ctx), *id)
	}
	if alias != nil {
		return services.ProgramService.GetByAlias(r.DB.WithContext(ctx), *alias)
	}
	return nil, fmt.Errorf("either id or alias must be provided")
}

// Program returns graph.ProgramResolver implementation.
func (r *Resolver) Program() graph.ProgramResolver { return &programResolver{r} }

type programResolver struct{ *Resolver }
