package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"

	"github.com/linn221/bane/app"
	"github.com/linn221/bane/graph"
	"github.com/linn221/bane/graph/model"
	"github.com/linn221/bane/loaders"
	"github.com/linn221/bane/models"
	"github.com/linn221/bane/mystructs"
	"github.com/linn221/bane/services"
)

// Program is the resolver for the program field.
func (r *endpointResolver) Program(ctx context.Context, obj *models.Endpoint) (*models.Program, error) {
	var program models.Program
	err := r.DB.First(&program, obj.ProgramId).Error
	if err != nil {
		return nil, err
	}
	return &program, nil
}

// HTTPPathMy is the resolver for the httpPathMy field.
func (r *endpointResolver) HTTPPathMy(ctx context.Context, obj *models.Endpoint, sep *string) (string, error) {
	myString := mystructs.NewMyStringFromVarString(obj.HttpPath)
	if sep != nil {
		myString.Separator = *sep
	}
	return myString.String(), nil
}

// HTTPQueriesMy is the resolver for the httpQueriesMy field.
func (r *endpointResolver) HTTPQueriesMy(ctx context.Context, obj *models.Endpoint, sep *string, limit *int) (string, error) {
	myString := mystructs.NewMyStringFromVarKVGroup(obj.HttpQueries, sep, limit)
	return myString.String(), nil
}

// HTTPHeadersMy is the resolver for the httpHeadersMy field.
func (r *endpointResolver) HTTPHeadersMy(ctx context.Context, obj *models.Endpoint, sep *string, limit *int) (string, error) {
	myString := mystructs.NewMyStringFromVarKVGroup(obj.HttpHeaders, sep, limit)
	return myString.String(), nil
}

// HTTPCookiesMy is the resolver for the httpCookiesMy field.
func (r *endpointResolver) HTTPCookiesMy(ctx context.Context, obj *models.Endpoint, sep *string, limit *int) (string, error) {
	myString := mystructs.NewMyStringFromVarKVGroup(obj.HttpCookies, sep, limit)
	return myString.String(), nil
}

// HTTPBodyMy is the resolver for the httpBodyMy field.
func (r *endpointResolver) HTTPBodyMy(ctx context.Context, obj *models.Endpoint) (string, error) {
	myString := mystructs.NewMyStringFromVarString(obj.HttpBody)
	return myString.String(), nil
}

// Match is the resolver for the match field.
func (r *endpointResolver) Match(ctx context.Context, obj *models.Endpoint, regex string) (*model.SearchResult, error) {
	return services.MatchRegex(obj, regex)
}

// Curl is the resolver for the curl field.
func (r *endpointResolver) Curl(ctx context.Context, obj *models.Endpoint, variables *string) (string, error) {
	var vars string
	if variables != nil {
		vars = *variables
	}
	return services.CurlServiceInstance.GenerateCurlCommand(obj, vars)
}

// Rid is the resolver for the rid field.
func (r *endpointResolver) Rid(ctx context.Context, obj *models.Endpoint) (int, error) {
	return loaders.GetRId(ctx, app.Reference{ReferenceId: obj.Id, ReferenceType: "endpoints"})
}

// Notes is the resolver for the notes field.
func (r *endpointResolver) Notes(ctx context.Context, obj *models.Endpoint) ([]*models.Note, error) {
	var notes []*models.Note
	err := r.DB.Where("reference_type = ? AND reference_id = ?", "endpoints", obj.Id).Find(&notes).Error
	return notes, err
}

// NewEndpoint is the resolver for the newEndpoint field.
func (r *mutationResolver) NewEndpoint(ctx context.Context, input models.NewEndpoint) (*models.Endpoint, error) {
	return services.EndpointService.CreateEndpoint(r.app, r.DB, &input)
}

// UpdateEndpoint is the resolver for the updateEndpoint field.
func (r *mutationResolver) UpdateEndpoint(ctx context.Context, id *int, alias *string, input models.NewEndpoint) (*models.Endpoint, error) {
	if id != nil {
		return services.EndpointService.UpdateEndpoint(r.app, r.DB.WithContext(ctx), *id, &input)
	}
	if alias != nil {
		return services.EndpointService.UpdateEndpointByAlias(r.app, r.DB.WithContext(ctx), *alias, &input)
	}
	return nil, fmt.Errorf("either id or alias must be provided")
}

// PatchEndpoint is the resolver for the patchEndpoint field.
func (r *mutationResolver) PatchEndpoint(ctx context.Context, id *int, alias *string, input models.PatchEndpoint) (*models.Endpoint, error) {
	if id != nil {
		return services.EndpointService.PatchEndpoint(r.app, r.DB.WithContext(ctx), *id, &input)
	}
	if alias != nil {
		return services.EndpointService.PatchEndpointByAlias(r.app, r.DB.WithContext(ctx), *alias, &input)
	}
	return nil, fmt.Errorf("either id or alias must be provided")
}

// DeleteEndpoint is the resolver for the deleteEndpoint field.
func (r *mutationResolver) DeleteEndpoint(ctx context.Context, id *int, alias *string) (*models.Endpoint, error) {
	if id != nil {
		return services.EndpointService.DeleteEndpoint(r.app, r.DB.WithContext(ctx), *id)
	}
	if alias != nil {
		return services.EndpointService.DeleteEndpointByAlias(r.app, r.DB.WithContext(ctx), *alias)
	}
	return nil, fmt.Errorf("either id or alias must be provided")
}

// ImportCurl is the resolver for the importCurl field.
func (r *mutationResolver) ImportCurl(ctx context.Context, curl string) (*models.CurlImportResult, error) {
	return services.ParseCurlCommand(curl)
}

// Endpoint is the resolver for the endpoint field.
func (r *queryResolver) Endpoint(ctx context.Context, id *int, alias *string) (*models.Endpoint, error) {
	if id != nil {
		return services.EndpointService.GetEndpointByID(r.app, r.DB.WithContext(ctx), *id)
	}
	if alias != nil {
		return services.EndpointService.GetEndpointByAlias(r.app, r.DB.WithContext(ctx), *alias)
	}
	return nil, fmt.Errorf("either id or alias must be provided")
}

// Endpoints is the resolver for the endpoints field.
func (r *queryResolver) Endpoints(ctx context.Context, filter *models.EndpointFilter) ([]*models.Endpoint, error) {
	return services.EndpointService.ListEndpoints(r.app, r.DB, filter)
}

// Endpoint returns graph.EndpointResolver implementation.
func (r *Resolver) Endpoint() graph.EndpointResolver { return &endpointResolver{r} }

type endpointResolver struct{ *Resolver }
