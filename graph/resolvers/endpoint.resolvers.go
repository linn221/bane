package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"

	"github.com/linn221/bane/app"
	"github.com/linn221/bane/graph"
	"github.com/linn221/bane/graph/model"
	"github.com/linn221/bane/loaders"
	"github.com/linn221/bane/models"
	"github.com/linn221/bane/mystructs"
	"github.com/linn221/bane/services"
)

// Program is the resolver for the program field.
func (r *endpointResolver) Program(ctx context.Context, obj *models.Endpoint) (*models.Program, error) {
	var program models.Program
	err := r.DB.First(&program, obj.ProgramId).Error
	if err != nil {
		return nil, err
	}
	return &program, nil
}

// Alias is the resolver for the alias field.
func (r *endpointResolver) Alias(ctx context.Context, obj *models.Endpoint) (*string, error) {
	alias, err := loaders.GetEndpointAlias(ctx, obj.Id)
	if err != nil {
		return nil, err
	}
	if alias == "" {
		return nil, nil
	}
	return &alias, nil
}

// HTTPPathMy is the resolver for the httpPathMy field.
func (r *endpointResolver) HTTPPathMy(ctx context.Context, obj *models.Endpoint, sep *string) (string, error) {
	myString := mystructs.NewMyStringFromVarString(obj.HttpPath)
	if sep != nil {
		myString.Separator = *sep
	}
	return myString.String(), nil
}

// HTTPQueriesMy is the resolver for the httpQueriesMy field.
func (r *endpointResolver) HTTPQueriesMy(ctx context.Context, obj *models.Endpoint, sep *string, limit *int) (string, error) {
	myString := mystructs.NewMyStringFromVarKVGroup(obj.HttpQueries, sep, limit)
	return myString.String(), nil
}

// HTTPHeadersMy is the resolver for the httpHeadersMy field.
func (r *endpointResolver) HTTPHeadersMy(ctx context.Context, obj *models.Endpoint, sep *string, limit *int) (string, error) {
	myString := mystructs.NewMyStringFromVarKVGroup(obj.HttpHeaders, sep, limit)
	return myString.String(), nil
}

// HTTPCookiesMy is the resolver for the httpCookiesMy field.
func (r *endpointResolver) HTTPCookiesMy(ctx context.Context, obj *models.Endpoint, sep *string, limit *int) (string, error) {
	myString := mystructs.NewMyStringFromVarKVGroup(obj.HttpCookies, sep, limit)
	return myString.String(), nil
}

// HTTPBodyMy is the resolver for the httpBodyMy field.
func (r *endpointResolver) HTTPBodyMy(ctx context.Context, obj *models.Endpoint) (string, error) {
	myString := mystructs.NewMyStringFromVarString(obj.HttpBody)
	return myString.String(), nil
}

// Match is the resolver for the match field.
func (r *endpointResolver) Match(ctx context.Context, obj *models.Endpoint, regex string) (*model.SearchResult, error) {
	return services.MatchRegex(obj, regex)
}

// Rid is the resolver for the rid field.
func (r *endpointResolver) Rid(ctx context.Context, obj *models.Endpoint) (int, error) {
	return loaders.GetRId(ctx, app.Reference{ReferenceId: obj.Id, ReferenceType: "endpoints"})
}

// Notes is the resolver for the notes field.
func (r *endpointResolver) Notes(ctx context.Context, obj *models.Endpoint) ([]*models.Note, error) {
	var notes []*models.Note
	err := r.DB.Where("reference_type = ? AND reference_id = ?", "endpoints", obj.Id).Find(&notes).Error
	return notes, err
}

// NewEndpoint is the resolver for the newEndpoint field.
func (r *mutationResolver) NewEndpoint(ctx context.Context, input models.EndpointInput) (*models.Endpoint, error) {
	return r.app.Services.EndpointService.Create(&input)
}

// Endpoint is the resolver for the endpoint field.
func (r *queryResolver) Endpoint(ctx context.Context, id *int, alias *string) (*models.Endpoint, error) {
	return r.app.Services.EndpointService.Get(id, alias)
}

// Endpoints is the resolver for the endpoints field.
func (r *queryResolver) Endpoints(ctx context.Context, filter *models.EndpointFilter) ([]*models.Endpoint, error) {
	return r.app.Services.EndpointService.List(filter)
}

// Endpoint returns graph.EndpointResolver implementation.
func (r *Resolver) Endpoint() graph.EndpointResolver { return &endpointResolver{r} }

type endpointResolver struct{ *Resolver }
