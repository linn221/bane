package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"

	"github.com/linn221/bane/graph"
	"github.com/linn221/bane/graph/model"
	"github.com/linn221/bane/models"
	"github.com/linn221/bane/services"
)

// CreateTag is the resolver for the createTag field.
func (r *mutationResolver) CreateTag(ctx context.Context, input models.NewTag) (*models.Tag, error) {
	return services.TagCrud.Create(r.DB, input)
}

// UpdateTag is the resolver for the updateTag field.
func (r *mutationResolver) UpdateTag(ctx context.Context, id int, input models.NewTag) (*models.Tag, error) {
	return services.TagCrud.Update(r.DB.WithContext(ctx), input, id)
}

// DeleteTag is the resolver for the deleteTag field.
func (r *mutationResolver) DeleteTag(ctx context.Context, id int) (*models.Tag, error) {
	return services.TagCrud.Delete(r.DB.WithContext(ctx), id)
}

// NewNote is the resolver for the newNote field.
func (r *mutationResolver) NewNote(ctx context.Context, input *models.NewNote) (*models.Note, error) {
	panic(fmt.Errorf("not implemented: NewNote - newNote"))
}

// Match is the resolver for the match field.
func (r *noteResolver) Match(ctx context.Context, obj *models.Note, regex string) (*model.SearchResult, error) {
	panic(fmt.Errorf("not implemented: Match - match"))
}

// NoteDate is the resolver for the noteDate field.
func (r *noteResolver) NoteDate(ctx context.Context, obj *models.Note) (*models.MyDate, error) {
	panic(fmt.Errorf("not implemented: NoteDate - noteDate"))
}

// Tag is the resolver for the tag field.
func (r *queryResolver) Tag(ctx context.Context, id int) (*models.Tag, error) {
	return services.TagCrud.Get(r.DB.WithContext(ctx), id)
}

// Tags is the resolver for the tags field.
func (r *queryResolver) Tags(ctx context.Context, search *string) ([]*models.Tag, error) {
	dbctx := r.DB.WithContext(ctx).Model(models.Tag{}).Where("is_active = 1")
	var results []*models.Tag
	err := dbctx.Find(&results).Error
	return results, err
}

// Notes is the resolver for the notes field.
func (r *queryResolver) Notes(ctx context.Context, rid *int, referenceID *int, referenceType *string) ([]*models.Note, error) {
	panic(fmt.Errorf("not implemented: Notes - notes"))
}

// Match is the resolver for the match field.
func (r *tagResolver) Match(ctx context.Context, obj *models.Tag, regex string) (*model.SearchResult, error) {
	var result model.SearchResult
	matches, err := services.MatchRegex(obj, regex)
	if err != nil {
		return nil, err
	}
	result.Results = matches
	count := len(matches)
	result.Count = &count

	return &result, nil
}

// RID is the resolver for the rId field.
func (r *newNoteResolver) RID(ctx context.Context, obj *models.NewNote, data *int) error {
	panic(fmt.Errorf("not implemented: RID - rId"))
}

// Note returns graph.NoteResolver implementation.
func (r *Resolver) Note() graph.NoteResolver { return &noteResolver{r} }

// Tag returns graph.TagResolver implementation.
func (r *Resolver) Tag() graph.TagResolver { return &tagResolver{r} }

// NewNote returns graph.NewNoteResolver implementation.
func (r *Resolver) NewNote() graph.NewNoteResolver { return &newNoteResolver{r} }

type noteResolver struct{ *Resolver }
type tagResolver struct{ *Resolver }
type newNoteResolver struct{ *Resolver }
